% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/maskmeans-package.R
\name{maskmeans}
\alias{maskmeans}
\title{Multi-view agglomeration or splitting K-means clustering algorithm}
\usage{
maskmeans(mv_data, clustering_init, type = "splitting", ...)
}
\arguments{
\item{mv_data}{Multi-view data, either in the form of a concatenated matrix (where the columns of the views have
been combined) or in the form of a list, where each element contains one of the views. In the former case, the argument
\code{mv} should also be provided to indicate the dimension of each of the views (\code{sum(mv)} should be equal to
the number of columns in the matrix). In the latter case, each matrix in the list should have observations (rows) sorted
in the same order, as matrices will be combined by columns within the function; note that \code{mv} will be detected 
automtically based on the number of columns in each matrix.}

\item{clustering_init}{Initial hard or fuzzy clustering to be used for aggregating or splitting clusters.}

\item{type}{Either \code{"splitting"} or \code{"aggregation"}.}

\item{...}{Additional optional parameters.}
}
\value{
Output from either \code{mv_aggregation} or \code{mv_splitting}, according to the \code{type} of algorithm
specified above.

For the aggregation algorithm, the outputs are as follows:
\item{merged_clusters }{Matrix providing each pair of merged clusters at each iteration of the algorithm}
\item{hclust }{Object of class "hclust" to be used for plotting cluster aggregations}
\item{weights }{Matrix of dimension \code{v} x \code{niterations}, where \code{v} is the number of
views and \code{niterations} is the number of successive agglomerations, providing the multi-view weights}
\item{criterion }{Value taken on by the agglomerative criterion at each iteration}
\item{final_classification }{Final classification of observations using \code{final_K} clusters (obtained by other cutting the
true at the appropriate level for the aggregation algorithm)}
\item{final_K }{Number of clusters chosen via model selection by the data-drive slope estimation (DDSE) slope heuristics}


For the splitting algorithm, the outputs are as follows:
\item{split_clusters }{Matrix providing the history of each cluster splitting at 
each iteration of the algorithm}
\item{weights }{Matrix of dimension \code{v} x \code{niterations}, where \code{v} is the number of
views and \code{niterations} is the number of successive agglomerations, providing the multi-view weights}
\item{criterion }{Value taken on by the splitting criterion at each iteration}
\item{withnss }{The within sum-of-squares for each cluster at the last iteration}
\item{ksplit }{Vector identifying which cluster was split at each iteration of the 
algorithm}
\item{final_classification }{Final classification of observations using \code{final_K} clusters (obtained by fixing the number 
of splits in the splitting algorithm)}
\item{final_K }{Number of clusters chosen via model selection by the data-drive slope estimation (DDSE) slope heuristics}
}
\description{
This is the primary function to run either the agglomeration or splitting version of the multi-view
K-means clustering algorithm
}
\examples{

## Simulate data
set.seed(12345)
sim_1 <- mv_simulate(type = "D1")
sim_2 <- mv_simulate(type = "D2")
sim_3 <- mv_simulate(type = "D3")
sim_4 <- mv_simulate(type = "D4")
sim_5 <- mv_simulate(type = "D5")
sim_6a <- mv_simulate(type = "D6")
sim_6b <- mv_simulate(type = "D6", delta=7, n=200, K=5, sigma=0.5)

X <- sim_6a$data
mv <- c(2,2,2,1,1,2)
gamma <- 2 
Xlist <- list(X[,1:2], X[,3:4], X[,5:6], matrix(X[,7], ncol=1), 
              matrix(X[,8], ncol=1), X[,9:10])
X_scale <- maskmeans:::scaleview(X, mv)

#-------------------------------------------------------------------
## Double-check that all functions provide the same result as before
#-------------------------------------------------------------------

#**************************************
## Test 1: hard clustering aggregation
#**************************************
cluster_init <- kmeans(Xlist[[1]], 20)$cluster
set.seed(12345)
hard_agglom <- maskmeans(mv_data=X, mv=mv, clustering_init=cluster_init, 
                         type = "aggregation", gamma=gamma) 
  
set.seed(12345)
hard_agglom_old <- maskmeans:::hmv1(X_scale, mv=mv, gamma=gamma, 
                        cluster.init=cluster_init, 
                        weightsopt = TRUE)
  
all.equal(hard_agglom$weights, hard_agglom_old$weights,
          check.attributes = FALSE)              
all.equal(hard_agglom$criterion, hard_agglom_old$CRIT)               
all.equal(hard_agglom$merged_clusters, hard_agglom_old$merge)

#**************************************
## Test 2: fuzzy clustering aggregation
#**************************************
set.seed(12345)
proba_init <- matrix(runif(nrow(X)*5), ncol=5)
proba_init <- proba_init / rowSums(proba_init)
fuzzy_agglom <- maskmeans(mv_data=X, mv=mv, clustering_init=proba_init, 
                          type = "aggregation", gamma=gamma) 
set.seed(12345)
fuzzy_agglom_old <- maskmeans:::hmvprobapost(X_scale, mv=mv, gamma=gamma, 
                                 probapost.init=proba_init)

all.equal(fuzzy_agglom$weights, fuzzy_agglom_old$weights, 
          check.attributes=FALSE)
all.equal(fuzzy_agglom$criterion, fuzzy_agglom_old$CRIT)           
all.equal(fuzzy_agglom$merged_clusters, fuzzy_agglom_old$merge)
  
#**************************************  
## Test 3: hard clustering splitting
#**************************************
set.seed(12345)
hard_split <- maskmeans(mv_data=X, mv=mv, clustering_init=cluster_init, 
                        type = "splitting", Kmax=20,
                        perCluster_mv_weights = FALSE)  

set.seed(12345)
hard_split_old <- maskmeans:::splittingClusters(X=X_scale, mv=mv, gamma=gamma, 
                                    Kmax=20, cluster.init=cluster_init,
                             weightsopt = TRUE, testkmeans = TRUE) 

all.equal(hard_split$weights, hard_split_old$weights, 
          check.attributes = FALSE) 
all.equal(hard_split$criterion, hard_split_old$CRIT)                         
all.equal(hard_split$split_clusters, hard_split_old$clustersplithist)          
all.equal(hard_split$ksplit, hard_split_old$ksplit, 
          check.attributes = FALSE)                             
all.equal(hard_split$withinss, hard_split_old$withinss, 
          check.attributes = FALSE)     


#**************************************
## Test 4: hard clustering splitting with per-weights
#**************************************
set.seed(12345)
cluster_init <- kmeans(Xlist[[1]], 10)$cluster
hard_split_perCluster <- maskmeans(mv_data=X, mv=mv, 
                                   clustering_init=cluster_init, type = "splitting", 
                                   Kmax=20, perCluster_mv_weights=TRUE, gamma=1) 

set.seed(12345)
hard_split_old_perCluster <- maskmeans:::splittingClustersbis(X=X_scale, mv=mv, gamma=1, 
                                                  Kmax=20, cluster.init=cluster_init) 

## Note: these are not identical as there was an error in the original code
mapply(all.equal, hard_split_perCluster$weights, hard_split_old_perCluster$weights, 
       check.attributes = FALSE)             
all.equal(hard_split_perCluster$criterion, hard_split_old_perCluster$CRIT)                        
all.equal(hard_split_perCluster$split_clusters, 
          hard_split_old_perCluster$clustersplithist)     
all.equal(hard_split_perCluster$ksplit, hard_split_old_perCluster$ksplit, 
          check.attributes = FALSE)                        
all.equal(hard_split_perCluster$withinss, hard_split_old_perCluster$withinss, 
          check.attributes = FALSE)           


#**************************************
## Test 5: fuzzy clustering splitting
#**************************************
\dontrun{
  
  set.seed(12345)
  proba_init <- matrix(runif(nrow(X)*5), ncol=5)
  proba_init <- proba_init / rowSums(proba_init)
  fuzzy_split <- maskmeans(mv_data=X, mv=mv, clustering_init=proba_init, 
                           type = "splitting", gamma=gamma, delta = 2,
                           perCluster_mv_weights = FALSE, Kmax = 7) 
  set.seed(12345)
  fuzzy_split_old <- maskmeans:::splittingProbapost(X=X_scale, mv=mv,
                                                    gamma=gamma, delta=2, Kmax=7, 
                                                    probapost.init=proba_init)
  ## TODO: NOT QUITE EQUAL?
  all.equal(fuzzy_split$weights, fuzzy_split_old$weights,
            check.attributes=FALSE)
  all.equal(fuzzy_split$criterion, fuzzy_split_old$CRIT)
  all.equal(fuzzy_split$probapost, fuzzy_split_old$probapost)
  
}



#**************************************
## Test 6: fuzzy clustering splitting with per-weights
#**************************************
\dontrun{
  
  set.seed(12345)
  fuzzy_split_perCluster <- maskmeans(mv_data=X, mv=mv, clustering_init=proba_init, 
                                      type = "splitting", gamma=gamma, delta = 2,
                                      perCluster_mv_weights = TRUE, Kmax = 7) 
  set.seed(12345)
  fuzzy_split_old_perCluster <- maskmeans:::splittingProbapostbis(X=X_scale, mv=mv,
     gamma=gamma, delta=2, Kmax=7, probapost.init=proba_init)
  all.equal(fuzzy_split_perCluster$weights, fuzzy_split_old_perCluster$weights, 
             check.attributes=FALSE)
  all.equal(fuzzy_split_perCluster$criterion, fuzzy_split_old_perCluster$CRIT)           
  all.equal(fuzzy_split_perCluster$probapost, fuzzy_split_old_perCluster$probapost)
  
}

#**************************************
## Other testing idea: using Xlist instead
#**************************************
hard_agglom_list <- maskmeans(mv_data=Xlist, clustering_init=cluster_init, 
                         type = "aggregation", gamma=gamma) 

#**************************************
## Plot functions
#**************************************

mv_plot(mv_data=sim_6a$data, mv=mv, labels=sim_6a$labels[,1])
mv_plot(mv_data=sim_1$data, mv=c(2,2,2,2), labels=sim_1$labels[,1])
mv_plot(mv_data=sim_2$data, mv=c(2,2,2,2), labels=sim_2$labels[,1])

p <- maskmeans_plot(hard_agglom, mv_data = X)
p <- maskmeans_plot(fuzzy_agglom, mv_data = X)
# p <- maskmeans_plot(hard_split, mv_data = X, edge_arrow=FALSE)  
# p <- maskmeans_plot(hard_split_perCluster, mv_data = X, edge_arrow=FALSE)  
p <- maskmeans_plot(hard_split, type="tree", mv_data=X_scale)  




}
