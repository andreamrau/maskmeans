% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/maskmeans-package.R
\name{maskmeans}
\alias{maskmeans}
\title{Multi-view agglomeration or splitting K-means clustering algorithm}
\usage{
maskmeans(mv_data, clustering_init, type = "splitting", ...)
}
\arguments{
\item{mv_data}{Multi-view data, either in the form of a concatenated matrix (where the columns of the views have
been combined) or in the form of a list, where each element contains one of the views. In the former case, the argument
\code{mv} should also be provided to indicate the dimension of each of the views (\code{sum(mv)} should be equal to
the number of columns in the matrix). In the latter case, each matrix in the list should have observations (rows) sorted
in the same order, as matrices will be combined by columns within the function; note that \code{mv} will be detected 
automtically based on the number of columns in each matrix.}

\item{clustering_init}{Initial hard or fuzzy clustering to be used for aggregating or splitting clusters.}

\item{type}{Either \code{"splitting"} or \code{"aggregation"}.}

\item{...}{Additional optional parameters.}
}
\value{
Output from either \code{mv_aggregation} or \code{mv_splitting}, according to the \code{type} of algorithm
specified above.
}
\description{
This is the primary function to run either the agglomeration or splitting version of the multi-view
K-means clustering algorithm
}
\examples{
# @example /inst/examples/maskmeans-package.R

## Simulate data
set.seed(12345)
sim_1 <- mv_simulate(type = "D1")
sim_2 <- mv_simulate(type = "D2")
sim_3 <- mv_simulate(type = "D3")
sim_4 <- mv_simulate(type = "D4")
sim_5 <- mv_simulate(type = "D5")
sim_6a <- mv_simulate(type = "D6")
sim_6b <- mv_simulate(type = "D6", delta=7, n=200, K=5, sigma=0.5)

X <- sim_6a$data
mv <- c(2,2,2,1,1,2)
gamma <- 2 
Xlist <- list(X[,1:2], X[,3:4], X[,5:6], matrix(X[,7], ncol=1), matrix(X[,8], ncol=1), X[,9:10])
X_scale <- scaleview(X, mv)

mv_plot(mv_data=sim_6a$data, mv=mv, labels=sim_6a$labels[,1])

#-------------------------------------------------------------------
## Double-check that all functions provide the same result as before
#-------------------------------------------------------------------

#**************************************
## Test 1: hard clustering aggregation
#**************************************
cluster_init <- sim_6a$labels[,1]
set.seed(12345)
hard_agglom <- maskmeans(mv_data=X, mv=mv, clustering_init=cluster_init, 
                         type = "aggregation", gamma=gamma) 
  
set.seed(12345)
hard_agglom_old <- hmv1(X_scale, mv=mv, gamma=gamma, cluster.init=cluster_init, 
                        weightsopt = TRUE)
  
all.equal(hard_agglom$weights, hard_agglom_old$weights,
          check.attributes = FALSE)              
all.equal(hard_agglom$criterion, hard_agglom_old$CRIT)               
all.equal(hard_agglom$merged_clusters, hard_agglom_old$merge)

#**************************************
## Test 2: fuzzy clustering aggregation
#**************************************
set.seed(12345)
proba_init <- matrix(runif(nrow(X)*5), ncol=5)
proba_init <- proba_init / rowSums(proba_init)
fuzzy_agglom <- maskmeans(mv_data=X, mv=mv, clustering_init=proba_init, 
                          type = "aggregation", gamma=gamma) 
set.seed(12345)
fuzzy_agglom_old <- hmvprobapost(X_scale, mv=mv, gamma=gamma, probapost.init=proba_init)

all.equal(fuzzy_agglom$weights, fuzzy_agglom_old$weights, check.attributes=FALSE)
all.equal(fuzzy_agglom$criterion, fuzzy_agglom_old$CRIT)           
all.equal(fuzzy_agglom$merged_clusters, fuzzy_agglom_old$merge)
  
#**************************************  
## Test 3: hard clustering splitting
#**************************************
set.seed(12345)
hard_split <- maskmeans(mv_data=X, mv=mv, clustering_init=cluster_init, type = "splitting", Kmax=20,
                        perCluster_mv_weights = FALSE)  

set.seed(12345)
hard_split_old <- splittingClusters(X=X_scale, mv=mv, gamma=gamma, Kmax=20, cluster.init=cluster_init,
                             weightsopt = TRUE, testkmeans = TRUE) 

all.equal(hard_split$weights, hard_split_old$weights, check.attributes = FALSE) 
all.equal(hard_split$criterion, hard_split_old$CRIT)                         
all.equal(hard_split$split_clusters, hard_split_old$clustersplithist)          
all.equal(hard_split$ksplit, hard_split_old$ksplit, check.attributes = FALSE)                             
all.equal(hard_split$withinss, hard_split_old$withinss, check.attributes = FALSE)     


#**************************************
## Test 4: hard clustering splitting with per-weights
#**************************************
set.seed(12345)
hard_split_perCluster <- maskmeans(mv_data=X, mv=mv, clustering_init=cluster_init, type = "splitting", 
                                   Kmax=20, perCluster_mv_weights=TRUE, gamma=1) 

set.seed(12345)
hard_split_old_perCluster <- splittingClustersbis(X=X_scale, mv=mv, gamma=1, 
                                                  Kmax=20, cluster.init=cluster_init) 

## Note: these are not identical as there was an error in the original code
mapply(all.equal, hard_split_perCluster$weights, hard_split_old_perCluster$weights, 
       check.attributes = FALSE)             
all.equal(hard_split_perCluster$criterion, hard_split_old_perCluster$CRIT)                        
all.equal(hard_split_perCluster$split_clusters, hard_split_old_perCluster$clustersplithist)     
all.equal(hard_split_perCluster$ksplit, hard_split_old_perCluster$ksplit, check.attributes = FALSE)                        
all.equal(hard_split_perCluster$withinss, hard_split_old_perCluster$withinss, check.attributes = FALSE)           


#**************************************
## Other testing idea: using Xlist instead
#**************************************
hard_agglom_list <- maskmeans(mv_data=Xlist, clustering_init=cluster_init, 
                         type = "aggregation", gamma=gamma) 
}
